---
layout: post
title: Yahoo! Logo ASCII Animation in six lines of C
---
<p>Last week I put together another obfuscated C program and have been urged by
my coworkers to post it publicly.  I've made some refinements since posting it
to our internal list, so here is the final version (to those who had seen it
already: it's one line shorter now, and the angles are less screwy, and the
animation is 2 seconds instead of 3).  Go ahead, try it:</p>

<pre>
$ cat &gt;yanim.c
c,p,i,j,n,F=40,k,m;float a,x,y,S=0,V=0;main(){for(;F--;usleep(50000),F?puts(
"\x1b[25A"):0)for(S+=V+=(1-S)/10-V/4,j=0;j&lt;72;j+=3,putchar(10))for(i=0;x=S*(
i-27),i++&lt;73;putchar(c[" ''\".$u$"]))for(c=0,n=3;n--;)for(y=S*(j+n-36),k=0,c
^=(136*x*x+84*y*y&lt;92033)&lt;&lt;n,p=6,m=0;m&lt;8;k++["&lt;[\\]O=IKNAL;KNRbF8EbGEROQ@BSX"
"XtG!#t3!^"]/1.16-68&gt;x*cos(a)+y*sin(a)?k=p,p="&lt;AFJPTX"[m++]-50:k==p?c^=1&lt;&lt;n,
m=8:0)a=(k["O:85!fI,wfO8!yZfO8!f*hXK3&fO;:O;#hP;\"i by asloane"]-79)/14.64;}
^D
$ gcc -o yanim yanim.c -lm
[warnings which real programmers ignore]
$ ./yanim
[you'll see]
</pre>

<p>It's a 20fps, antialiased ASCII art animation of the Yahoo! logo.  If you
want to figure out how it works on your own, you're welcome to.  Otherwise,
read on.</p>

<p>I encourage you to play with the constants in the code: S+=V+=(1-S)/10-V/5
is the underdamped control system for the animation -- S is scale (=1/zoom), V
is velocity, and 1/10 and 1/5 are the <a
  href="http://en.wikipedia.org/wiki/PID_controller">PD constants</a> [TODO:
check this link].  S=0 corresponds to infinite zoom on the first frame.  S&lt;0
is funny.  F is the frame counter.  The 1.16 controls the scale of the polygon
rendering (68 is an approximation of 79/1.16 so you have to adjust that too),
and 136/84/92033 define the ellipse.  The 14.64 is not a tunable parameter,
though (it's 46/pi, and for a good reason).</p>

<p>The antialiasing is simple: each character consists of three
vertically-arranged samples and an 8-character lookup table for each
arrangement of three on/off pixels.  Each frame consists of 73x24 characters,
or 73x72 pixels.  The 73 horizontal choice was somewhat arbitrary; I suppose I
could have gone up to 79.</p>

<p>The logo is rendered as an ellipse and eight convex polygons using a fairly
neat method (I thought) with no frame buffer and sub-pixel precision.  It
required some design tradeoffs to fit into two printable-character arrays, but
it's much less code than rendering triangles to a framebuffer, which is the
typical way polygon rasterization is done.</p>

<p>To produce this, first I had to vectorize the "Y!" logo.  I did this by
taking some measurements of a reference image and writing coordinates down on
graph paper.  Then I wrote a utility program which takes the points and polygon
definitions and turns them into angles and offsets as defined below.</p>

<p>The ellipse is fairly standard high-school math:
<i>x</i><sup>2</sup>/<i>a</i><sup>2</sup> +
<i>y</i><sup>2</sup>/<i>b</i><sup>2</sup> &lt; 1.  Each point is tested and if
it's inside the ellipse, the pixel is plotted.  (136<i>x</i><sup>2</sup> +
84<i>y</i><sup>2</sup> &lt; 92033 was a trivial rearrangement of terms with
<i>a</i> and <i>b</i> being the radii of the two axes of the ellipse measured
from my source image, scaled to the pixel grid).  </p>

<p>Each polygon is made up of a set of separating half-planes (a half-plane
being all points on one side of an infinitely long line).  If a given point is
"inside" all of the half-planes, it's inside the polygon (which only works as
long as the polygon is convex) and the pixel is toggled with the XOR operator
<tt>^</tt> (thus it handles the "inverse" part inside the ellipse as well as
the uninverted exclamation mark without any special cases).  Each side of a
polygon is defined by the equation <i>ax</i> + <i>by</i> &gt; <i>c</i>.  To
represent both <i>a</i> and <i>b</i> I use an angle <i>&theta;</i> so that
<i>a</i> = cos(<i>&theta;</i>) and <i>b</i> = sin(<i>&theta;</i>) and quantize
the angle in &pi;/46 increments &mdash; my angles are thus represented from
-&pi; to +&pi; as ASCII 33 to 125 &mdash; '!' to '}' &mdash; with 'O' (ASCII
79) as zero.  Then I solve for <i>c</i>, also quantized in scaled increments
from -47 to +47, so that the midpoint of the side is considered inside the
polygon.</p>

<p>Here's an extremely crude diagram:  (I'm writing this on a plane and none of
my drawing programs are working.  Sorry.)</p> <img src="/img/crap1.png" /> <p>The
shaded area is <i>ax</i> + <i>by</i> &lt; <i>c</i>, implying it's outside the
polygon, and the dashed line is <i>ax</i> + <i>by</i> = <i>c</i>.</p>

<p>(<i>a</i>,<i>b</i>) form a vector orthogonal to the line segment they
represent pointing towards the inside of the polygon, so we can get them
directly from the points defining the line segment by flipping <i>x</i> and
<i>y</i> and negating <i>y</i>.  (<i>x<sub>t</sub></i>, <i>y<sub>t</sub></i>)
is the midpoint between the points making up the line segment &mdash; I use
this instead of either side of the line segment when solving for <i>c</i>
because the angle can be slightly off after we quantize to one of 94 angles,
and this evens the errors out across the side of the polygon.</p>

<p>You'll notice on the first couple frames (you can pause with ^S, resume with
^Q -- xon/xoff) that the bottom section of the 'Y' has little bites taken out
of it due to the quantization error in the separating half-plane equations.
</p>

<p>It could probably be made somewhat more efficient CPU-wise by careful
reordering of the separating plane arrays so that most of the drawing area is
rejected first.  I didn't get to that in my generator code.</p>

<p>The animation is done by the &lt;ESC&gt;[25A sequence &mdash; it moves the
cursor up 25 lines in just about any terminal emulation mode.  I technically
only need to move up 24 lines, but <tt>puts</tt> is shorter than
<tt>printf</tt> and it implicitly adds a newline.  If your terminal isn't at
least 26 lines high, though, it does funky things to your scrollback.  And
<tt>usleep</tt> is there to limit it to 20fps, which is the only non-ANSI Cism
about it.</p>

<p>And then I shrunk the code down by arranging it into clever <tt>for</tt>
loops and taking unorthodox advantage of commas, conditionals, and globals
being <tt>int</tt>s by default in C (which all par for the course in obfuscated
C code).  And that pretty much reveals all the secrets as to how it was
done.</p>

<p>It would be fairly easy to enhance this with a different movement sequence,
or rotation (or any kind of 3D transform, as it's basically just ray-tracing
the logo).  I just animated the scale to prove the point that it was being
rendered dynamically and not just a compressed logo, and kept the animation
short and sweet.</p>

<p>I apologize in advance for the various sign errors I'm sure to have made
when typing this up, but you get the idea.</p>

